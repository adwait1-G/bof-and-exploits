# Guardians of the Stack: Cheatsheet

## 1. sof/ directory

1. To generate the **sof** executable inside "sof/" directory, use the following command:

```
sof$ gcc sof.c -o sof -fno-stack-protector -no-pie
```

To run the exploit, first generate the **payload.txt** by running **exploit.py** script.

```
sof$ chmod u+x exploit.py
sof$ ./exploit.py
```

Then pipe the contents of payload.txt into the executable.

```
sof$ cat payload.txt - | ./sof
```


## 2. shellcode/ directory

### 2.1 Generating shellcode

There are 2 assembly files(exit.S and execve.S). The following commands can be used to generate machine code(or shellcode) from it.

1. Consider exit.S for now.
2. Assemble it using "nasm" command.

```
shellcode$ nasm exit.S -f elf64
```

3. Disassemble the exit.o file generated to get the machine code.

```
shellcode$ objdump -Mintel -d exit.o

exit.o:     file format elf64-x86-64

Disassembly of section .text:

0000000000000000 <_start>:
    0:  b8 3c 00 00 00          mov eax,0x3c
    5:  bf 01 00 00 00          mov edi,0x1
    a:  0f 05                   syscall
```

The same can be done for execve.S as well.

### 2.2 Generating executables.

1. To generate **shellcode** executable, you may use the following command:

```
shellcode$ gcc shellcode.c -o shellcode -fno-stack-protector -no-pie -zexecstack
```

Please use the exact flags.

2. To generate the **sof_sc** executable, the following can be used.

```
shellcode$ gcc sof.c -o sof_sc -fno-stack-protector -no-pie -zexecstack
```

### 2.3 Running the exploit

To run the exploit, first generate the **payload.txt** by running **exploit.py** script.

```
shellcode$ chmod u+x exploit.py
shellcode$ ./exploit.py
```

Then pipe the contents of payload.txt into the executable.

```
shellcode$ cat payload.txt - | ./sof_mc
```

## 3. ret2libc/ directory

To generate the **sof_ret2libc** executable,

```
ret2libc$ gcc sof.c -o sof_ret2libc -fno-stack-protector -no-pie -m32
```

Note that we are generating 32-bit binary for the sake of this experiment.

### 3.1 Running the exploit

To run the exploit, first generate the **payload.txt** by running **exploit.py** script.

```
ret2libc$ chmod u+x exploit.py
ret2libc$ ./exploit.py
```

Then pipe the contents of payload.txt into the executable.

```
ret2libc$ cat payload.txt - | ./sof_ret2libc
```

## 4. rop/ directory

### 4.1 Generating executables

1. To generate **sof_rop** executable,

```
rop$ gcc sof.c -o sof_rop -fno-stack-protector -no-pie
```

2. To generate **sof_rop_static** executable,

```
rop$ gcc sof.c -o sof_rop_static -fno-stack-protector -no-pie --static
```

### 4.2 Harvesting gadgets

You may use the ROPgadgets tool to get the gadgets.

```
rop$ ROPgadget --binary sof_rop_static > sof_rop_static.rop.obj
```

The same command can be used for any other binary.

### 4.3 Running the exploit

To run the exploit, first generate the **payload.txt** by running **exploit.py** script.

```
rop$ chmod u+x exploit.py
rop$ ./exploit.py
```

Then pipe the contents of payload.txt into the executable.

```
rop$ cat payload.txt - | ./sof_rop_static
```

Note that the exploit is written keeping **sof_rop_static** in mind.

## 5. srop/ directory

1. To generate the **loop** executable,

```
srop$ gcc loop.c -o loop -no-pie
```

2. To generate the **signal** executable,

```
srop$ gcc signal.c -o signal -no-pie
```

3. To geneate the **sof_srop** executable,

```
srop$ gcc sof.c -o sof_srop -fno-stack-protector -no-pie --static
```

### 5.1 Running the exploit

To run the exploit, first generate the **payload.txt** by running **exploit.py** script.

```
rop$ chmod u+x exploit.py
rop$ ./exploit.py
```

Then pipe the contents of payload.txt into the executable.

```
srop$ cat payload.txt - | ./sof_srop
```

## 6. Other helpful commands

**1**. **readelf** is a binary reading tool - it parses a binary(object file, executable, shared library, core etc.,) and prints information in human-readable form.
    - To generate the list of program headers, you may use ```*readelf -l <binary-name>```.

**2**. To get disassembly of any binary, you may use **objdump**.

```
sof$ objdump -Mintel -d sof > sof.obj
```

This will convert all the machine code into assembly code(disassemble it) and dumps into **sof.obj** file.

**3**. If you want to input a binary string into an executable, you may use **python** to do it.

```
shellcode$ python -c "print '\x90\x90\xc3'" | ./shellcode
```

or

```
shellcode$ python -c "print '\xb8\x3c\x00\x00\x00\xbf\x01\x00\x00\x00\x0f\x05'" | ./shellcode
```

This specifically helps in building an exploit quickly - rather than going changing and running the **exploit.py** file everytime.

**4**. The memory layout of any process will be present in **/proc/PID/maps** file.

- First run the process.

```
shellcode$ ./shellcode
```

- On another terminal instance, get the Process-ID(PID) of the desired process.

```
shellcode$ ps -e | grep shellcode
27186 pts/0    00:00:00 shellcode
```

- Using this, we can checkout its **maps** file.

```
shellcode$ cat /proc/27186/maps
555555554000-555555555000 r-xp 00000000 08:02 2110930                    /home/agautham/Desktop/seccon-bootcamp/seccon-bootcamp2/shellcode/shellcode
555555754000-555555755000 r-xp 00000000 08:02 2110930                    /home/agautham/Desktop/seccon-bootcamp/seccon-bootcamp2/shellcode/shellcode
555555755000-555555756000 rwxp 00001000 08:02 2110930                    /home/agautham/Desktop/seccon-bootcamp/seccon-bootcamp2/shellcode/shellcode
555555756000-555555777000 rwxp 00000000 00:00 0                          [heap]
7ffff79e2000-7ffff7bc9000 r-xp 00000000 08:02 524372                     /lib/x86_64-linux-gnu/libc-2.27.so
7ffff7bc9000-7ffff7dc9000 ---p 001e7000 08:02 524372                     /lib/x86_64-linux-gnu/libc-2.27.so
7ffff7dc9000-7ffff7dcd000 r-xp 001e7000 08:02 524372                     /lib/x86_64-linux-gnu/libc-2.27.so
7ffff7dcd000-7ffff7dcf000 rwxp 001eb000 08:02 524372                     /lib/x86_64-linux-gnu/libc-2.27.so
7ffff7dcf000-7ffff7dd3000 rwxp 00000000 00:00 0 
7ffff7dd3000-7ffff7dfc000 r-xp 00000000 08:02 524311                     /lib/x86_64-linux-gnu/ld-2.27.so
7ffff7fde000-7ffff7fe0000 rwxp 00000000 00:00 0 
7ffff7ff8000-7ffff7ffb000 r--p 00000000 00:00 0                          [vvar]
7ffff7ffb000-7ffff7ffc000 r-xp 00000000 00:00 0                          [vdso]
7ffff7ffc000-7ffff7ffd000 r-xp 00029000 08:02 524311                     /lib/x86_64-linux-gnu/ld-2.27.so
7ffff7ffd000-7ffff7ffe000 rwxp 0002a000 08:02 524311                     /lib/x86_64-linux-gnu/ld-2.27.so
7ffff7ffe000-7ffff7fff000 rwxp 00000000 00:00 0 
7ffffffde000-7ffffffff000 rwxp 00000000 00:00 0                          [stack]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
```

Similarly, you can checkout **maps** file of any process.

## 7. ASLR

To disable ASLR, execute the following command as **root** user.

```
# echo 0 > /proc/sys/kernel/randomize_va_space
```

To enable ASLR for only stack, heap, libraries,

```
# echo 1 > /proc/sys/kernel/randomize_va_space
```

To enable ASLR for all spaces(stack, heap, libraries, text, data, bss etc.,), you may use

```
# echo 2 > /proc/sys/kernel/randomize_va_space
```

## 8. Basic gdb commands

1. To run a program with gdb,

```
rop$ gdb -q sof_rop_static
Reading symbols from sof_rop_static...(no debugging symbols found)...done.
gdb-peda$
```

2. To apply breakpoints at particular places, you may use the ```b``` or ```break``` command.

```
rop$ gdb -q sof_rop_static
Reading symbols from sof_rop_static...(no debugging symbols found)...done.
gdb-peda$ b echo
Breakpoint 1 at 0x400b8e
gdb-peda$
gdb-peda$ break main
gdb-peda$ break main
Breakpoint 2 at 0x400c11
gdb-peda$
```

3. use the ```run``` command to execute.

```
gdb-peda$ run
```

4. If you want to go to next instruction, use the ```ni``` command.
5. If you want to get into a function (or step into a function), use **si** command.
6. To checkout a process's memory layout, use "info proc map"
7. To find something, you may use "find <string to find>".

```
gdb-peda$ find "/bin/sh"
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
sof_rop_static : 0x492304 --> 0x68732f6e69622f ('/bin/sh')
gdb-peda$
```

8. To catch a signal, you first have to enable it in gdb. The following shows that catching is not enabled for SIGINT signal.

```
gdb-peda$ handle SIGINT
Signal        Stop	Print	Pass to program	Description
SIGINT        Yes	Yes	No		Interrupt
```

- Use the following command to enabled it.

```
gdb-peda$ handle SIGINT pass
Signal        Stop	Print	Pass to program	Description
SIGINT        Yes	Yes	Yes		Interrupt
```

- To disable it, you may use "nopass".

```
gdb-peda$ handle SIGINT nopass
Signal        Stop	Print	Pass to program	Description
SIGINT        Yes	Yes	No		Interrupt
```

## 9. Using strace and ltrace

**strace** is a system-call trace tool which will list all the system calls executed by your process. The following is an example:

```
$ strace ./sof_rop_static
execve("./sof_rop_static", ["./sof_rop_static"], 0x7ffccd9969b0 /* 55 vars */) = 0
brk(NULL)                               = 0x1165000
brk(0x11661c0)                          = 0x11661c0
arch_prctl(ARCH_SET_FS, 0x1165880)      = 0
uname({sysname="Linux", nodename="agbox", ...}) = 0
readlink("/proc/self/exe", "/home/agautham/Desktop/seccon-bo"..., 4096) = 80
brk(0x11871c0)                          = 0x11871c0
brk(0x1188000)                          = 0x1188000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0
write(1, "Before echo()\n", 14Before echo()
)         = 14
write(1, "Enter a string: ", 16Enter a string: )        = 16
fstat(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0
read(0, qwerty
"qwerty\n", 1024)               = 7
write(1, "qwerty\n", 7qwerty
)                 = 7
write(1, "After echo()\n", 13After echo()
)          = 13
exit_group(0)                           = ?
+++ exited with 0 +++
```

**ltrace** is a library-call tracing tool - which will list all the library functions(not just C library but any) executed by your program.

```
$ ./sof_rop
puts("Before echo()"Before echo()
)                            = 14
fflush(0x7fab90244760)                           = 0
printf("Enter a string: ")                       = 16
fflush(0x7fab90244760Enter a string: )                           = 0
gets(0x7ffe25c4bff0, 0x7fab902458c0, 0, 0x7fab8ff68224qwerty
) = 0x7ffe25c4bff0
fflush(0x7fab90243a00)                           = 0
puts("qwerty"qwerty
)                                   = 7
fflush(0x7fab90244760)                           = 0
puts("After echo()"After echo()
)                             = 13
fflush(0x7fab90244760)                           = 0
+++ exited (status 0) +++
```

## 10. Installing peda

1. Create a directory with the name "gdb-init" in your home-directory.

```
~$ mkdir gdb-init
~$ cd gdb-init
~/gdb-init$
```

2. Download the peda (Python Exploit Development Assistance) kit from github.

```
~/gdb-init$ git clone https://github.com/longld/peda
Cloning into 'peda'...
remote: Enumerating objects: 382, done.
remote: Counting objects: 100% (9/9), done.
remote: Compressing objects: 100% (9/9), done.
remote: Total 382 (delta 2), reused 2 (delta 0), pack-reused 373
Receiving objects: 100% (382/382), 290.84 KiB | 280.00 KiB/s, done.
Resolving deltas: 100% (231/231), done.
```

3. Go back to your home directory and create a file with name ```.gdbinit```.

```
~$ touch .gdbinit
```

4. Put the peda script(peda.py) as one of the gdb-scripts in the above file.

```
~$ echo "source /home/agautham/gdb-init/peda/peda.py" > .gdbinit
```

With that, instead of seeing a normal gdb console like the following,

```
(gdb)
```

you would instead look at the following:

```
gdb-peda$
```

gdb-peda is gdb on steroids! It is an amazing script which will help us debug and understand programs faster than the native, simple gdb.


